# 스프링 핵심 원리 - 기본편

- [x]  **섹션 0. 강의 소개**

- **섹션 1. 객체 지향 설계와 스프링**
    - 자바 진영의 추운 겨울과 스프링의 탄생
        - J2EE(Enterprise Java Bean)이 있었는데 SI 개발자 로드 존슨이 이를 대체할 기술 코드를 작성 → **Spring**
        - 게빈 킹이 EJB 엔티티빈보고 이거보단 내가 더 잘하겠다 해서 만든게 **Hibernate**
    - 스프링이란?
        - **스프링 부트**
            - 스프링을 편리하게 사용하게 해주는 기능
            - Tomcat 웹 서버 내장
            - 서드파티 라이브러리 자동구성 → 외부 라이브러리 버전관리
            - 메트릭, 모니터링 기능 + 간결한 설정
        - 스프링?
            - 스프링 DI 컨테이너 기술
            - 스프링 프레임워크
            - 스프링 부트, 스프링 프레임워크를 포함한 스프링 생태계 모두
        - 스프링을 왜 만들었나요?
            - 스프링은 **자바**기반 프래임워크
            - 자바 언어의 큰 특징은 **객체 지향 언어**
            - **좋은 객체 지향 애플리케이션을 개발할 수 있게 도와주는 프레임워크**
    - 좋은 객체지향 프로그래밍이란?
        - 객체지향의 특징 : 추상화, 캡슐화, 상속, **다형성**
        - 객체 지향 프로그램 : **객체들의 모임.**  각각의 객체는 메시지를 주고받고 처리한다. **(협력)**
            
            → 유연하고 변경에 용이하다 → 대규모 프로젝트에 사용 용이
            
        - **다형성**
            - **역할**(Interface)
            - **구현**(Implement)
            
               ⇒ 구현이 아니라 역할에 의존한다.
            
               ⇒ **역할**과 **구현**으로 구분하면 세상이 **단순**해지고, **유연**해지며 **변경**도 편리해진다
            
            - **클라이언트**는 대상의 역할만 알면 된다.
        - **다형성의 본질**
            - 인터페이스를 구현한 객체 인스턴스를 실행 시점에 유연하게 변경 가능
            - “협력”이라는 객체사이의 관계에서 시작해야 본질을 이해할 수 있다.
            - 클라이언트를 변경하지 않고, 서버의 구현 기능을 유연하게 변경 가능하다.
        - 스프링과 객체지향
            - 스프링은 다형성을 극대화한다.
            - 제어의 역전(IoC), 의존관계 주입(DI) ⇒ 다형성을 활용 ⇒ 역활과 구현을 분리
    - 좋은 객체 지향 설계의 5가지 원칙(SOLID)
        - **SRP: 단일 책임 원칙(Single responsibility)**
            - 한 클래스는 **하나의 책임**만 가져야 한다.
            - 기준은 **변경**이다. 변경이 있을 때 파급 효과가 적어야 한다.
            - ex) UI 변경, 객체의 생성/사용을 분리
        - **OCP: 개방-폐쇄 원칙(Open-Closed)**
            - **확장**에는 열려있으나 **변경**에는 닫혀 있어야 한다.
                
                ⇒ **다형성**
                
            - 구현객체를 변경하려면 클라이언트 코드를 변경해야한다...
                
                ⇒ 다형성을 사용했지만 **OCP 원칙을 지킬 수 없다.**
                
            - 그럼.. 어떡해요 ?
                
                ⇒ 객체를 생성, 연관관계를 맺어주는 별도의 조립, 설정자가 필요하다.
                
        - **LSP: 리스코프 치환원칙(Liskov substitution)**
            - 프로그램의 객체는 프로그램의 정확성을 깨드리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
            - 다형성에서 하위 클래스는 인터페이스 규약을 지켜야 한다는 것.
            - 단순히 컴파일 단계 성공/실패를 뜻하는게 아니다.
            - 자동차 인터페이스의 엑셀은 앞으로 가라는 기능, 뒤로 가면 LSP 위반
            - 즉, 이 인터페이스의 구현체를 **믿고 사용하려면** 이 원칙이 필요하다.
        - **ISP: 인터페이스 분리 원칙(Interface seregation)**
            - 특정 클라이언트를 위한 인터페이스 여러개가 범용 인터페이스보다 낫다.
            - 자동차 인터페이스 → 운전 인터페이스
                
                                               → 정비 인터페이스
                
            - 사용자 클라이언트 → 운전자 클라이언트
                
                                               → 정비사 클라이언트
                
            - 분리하면, 정비 인터페이스가 분리되어도 운전자 클라이언트에 영향을 주지 않음
            - 인터페이스가 명확해지고, 대체 가능성이 높아진다.
        - **DIP 의존관계 역전 원칙 (Dependency inversion)**
            - 프로그래머는 “추상화에 의존해야지,구체화에 의존하면 안된다”
            - 클라이언트 코드가 구현 클래스를 보지말고, 인터페이스만 바라봐야 한다.
                
                ⇒ **구현이 아니라 역할에 의존하는 것과 똑같은 의미**
                
                ⇒ 운전자는 구현된 K3가 아니라 ‘자동차’라는 역할을 알아야 한다.
                
        
        - 다형성만 사용하면, 구현 객체 변경할때 클라이언트 코드가 변경된다.
            
            $**\therefore$   다형성 만으로는 OCP, DIP를 지킬 수 없다.**
            
    - 객체 지향 설계와 스프링
        - 스프링은 **DI**, **DI컨테이너**로 OCP, DIP를 가능하게 지원
        - 구현체보다 인터페이스를 먼저 만들면 되지만,,, 추상화 라는 비용 발생 
        (구현 만들고 나중에 인터페이스 만들어도 된다.)
        - 
- **섹션 2. 스프링 핵심 원리 이해1 - 예제 만들기**
    - 클래스 다이어그램은 정적이다.
    - 객체 다이어그램은 동적이다.(실행-컴파일 시 실제 객체 주입)
    - Test - given, when, then
    
- **섹션 3. 스프링 핵심 원리 이해2 - 객체 지향 원리 적용**
    - 관심사의 분리
        - 구현체에도, 인터페이스에도 의존적이다. → DIP, OCP 위반
        - AppConfig의 등장
            
            → AppConfig에서 실제 구현 객체를 생성한다.
            
            → 인터페이스에만 의존하도록 생성자 주입(서비스는 어떤 구현체를 사용하는지 모른다)
            
            → DIP를 지킬수 있도록!
            
            → 서비스는 이제 “**의존관계에 대한 고민은 외부**”에 맡기고 “**실행**”에만 집중한다
            
        - 객체의 생성과 연결은 ‘AppConfig’가 담당한다
            
            **→ 관심사의 분리 :** 객체를 생성하고 연결하는 역활과 실행하는 역활이 분리되었다.
            
        - AppConfig가 구현체 memoryMemberRepo를 생성하고, MemberServiceImpl을 생성하면서 주입한다.(생성자 주입)
            
            → memberServiceImpl입장에서 외부에서 **의존관계를 주입하는 것** 같이 보인다.
            
    - 좋은 객체 지향 설계의 5가지 원칙 적용
        - **SRP 단일 책임 원칙**
            - 클라이언트 객체는 직접 구현 객체 생성, 연결, 실행하는 다양한 책임을 갖고 있었음
            - AppConfig가 구현 객체를 생성하고 연결함
            - 클라이언트 객체는 실행하는 책임만 담당
        - **DIP 의존관계 역전 원칙**
            - 프로그래머는 **“추상화에 의존해야지, 구체화에 의존하면 안된다.”**
        - **OCP**
            - **소프트웨어 요소는 확장에는 열려있으나, 변경에는 닫혀있어야 한다.**
            - 다형성  + 클라이언트가 DIP를 지킴
                
                → 사용 영역 / 구성 영역으로 나뉨
                
            - **“소프트웨어 요소를 새롭게 확장해도(DiscountPolicy 새로 생김) 사용 영역(클라이언트) 변경은 닫혀있다.”**
            
    - IoC, DI, 그리고 컨테이너
        - 제어의 역전 IoC (Inversion of Control)
            
            기존 프로그램은 클라이언트 구현 객체가 스스로 서버가 필요한 서버구현 객체를 생성, 연결, 실행했다. 
            
            → 즉, **구현 객체**가 **프로그램의 제어 흐름**을 스스로 조종했다.
            
            - AppConfig 등장 이후
                
                구현 객체는 자신의 로직을 실행하는 역할만 담당한다. 즉, 어떠한 구현체(ex OrderServiceImpl)가 사용될 지 모른다.
                
                → 프로그램에 대한 제어 흐름은 모두 **AppConfig**가 가져가게 된다
                
            - **프레임워크 vs 라이브러리**
                
                프레임워크는 내 코드가 프레임워크 속에 콜백 함수처럼 들어가는 것이고 
                
                → (프레임워크의 라이프 사이클 존재)
                
                라이브러리는 내 코드속에 함수가 순차적으로 존재하는 것이다.
                
                → (라이프 사이클 X)
                
        - 의존관계 주입 DI(Dependency Injection)
            
            의존 관계는 “**정적인 클래스 의존 관계와, 실행 시점에 결정되는 동적인 객체(인스턴스) 의존 관계**’를 분리해야 한다.
            
            - **정적인 클래스 의존관계 ( 클래스 다이어그램 )**
                - 클래스가 사용하는 import 코드만 보고 쉽게 판단할 수 있다.
                - 애플리케이션을 실행하지 않아도 분석할 수 있다.
                - **그러나** 이런 의존관계 만으로는 어떤 실제 어떤 객체가 주입될지 알 수 없다.
            - **동적인 객체 인스턴스 의존관계 ( 객체 다이어그램)**
                - 애플리케이션 실행시점마다 외부에서 실제 구현 객체를 생성, 클라이언트에게 전달해서 클라이언트와 서버의 실제 의존관계가 연결되는 것을 “**의존관계** **주입**” 이라고 한다.
                - 의존 관계 주입을 사용하면, 
                ⇒ 클라이언트 코드 변경없이 호출하는 대상의 타입 인스턴스를 변경 가능
                    
                    ⇒ *(다른 말로), 정적인 클래스 의존관계를 변경하지 않고, 동적인 객체 인스턴스 의존관계를 쉽게 변경할 수 있다.
                    
        - **IoC 컨테이너, DI 컨테이너**
            
            **AppConfig** 처럼 객체를 생성, 관리하며 의존관계를 연결해 주는 것을
            
            IoC컨테이너 / **DI컨테이너** 라고한다.
            
    - **스프링 컨테이너**
        
        ```jsx
        'ApplicationContext' => 스프링 컨테이너라 한다
        ```
        
- [ ]  **섹션 4. 스프링 컨테이너와 스프링 빈**

- [ ]  **섹션 5. 싱글톤 컨테이너**

- [ ]  **섹션 6. 컴포넌트 스캔**

- [ ]  **섹션 7. 의존관계 자동 주입**
- [ ]  **섹션 8. 빈 생명주기 콜백**
- [ ]  **섹션 9. 빈 스코프**
